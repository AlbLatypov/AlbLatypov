## Без curl/wget/telnet делать tcp/udp запросы.

Порой бывает что на серверах нет курла, вегета (как приправа с упоротым поваром) и даже пинга. Например в docker контейнерах. И установить никак. Но в bash скрипте или во время дебага надо протестировать приложение, службу или порт.


Я обычно при дебаге использую telnet, чтобы проверить открыт ли нужный порт на удаленной тачке. Чтобы понимать, что никакой фаервол меня не блокирует. Почему telnet? Привычка!

Проверяем открыт ли порт 80 и 443:

`:> /dev/tcp/bashdayz.ru/80`
`:> /dev/tcp/bashdayz.ru/443`

Если порт открыт, то после выполнения команды на экран ничего не выведется. Но ты в праве получить статус через echo $?. Если вернулся 0 значит порт открыт и все ок. Если вернулось > 0, то порт закрыт.

Есть нюанс, команда может висеть очень долго, поэтому приправляем ее таймаутом:

`timeout 5s bash -c ':> /dev/tcp/bashdayz.ru/80'`
`timeout 5s bash -c ':> /dev/tcp/bashdayz.ru/443'`

Теперь в случае если порт не доступен, мне не нужно ждать 100500 часов пока команда завершится. Все станет известно спустя 5 секунд. Повторюсь, что на экран никакого вывода не будет. Статус получаем через echo $?, ну ты понял.

#### А что означает этот непонятный символ «:>»?

Это сокращенная версия true:

`true > /dev/tcp/bashdayz.ru/80`

__true__ - команда, которая всегда возвращает успешный (нулевой) код возврата. Это означает, что команда завершилась успешно, без ошибок.

Чтобы весь этот фокус работал, требуется bash с поддержкой net-redirections (--enable-net-redirections), но как показывает практика такая функция в 99% включена по умолчанию, если конечно ты не адепт gentoo и из исходников bash собирал.

Аналогично можно слать udp запросы:

`:> /dev/udp/localhost/8888`

То есть синтаксис простой: `/dev/протокол/хост/порт`

Давай еще пример покажу как с NIST Time Server получить актуальную дату и время с разных NTP:

`cat </dev/tcp/time.nist.gov/13`
`cat </dev/tcp/time.cloudflare.com/13`
`cat </dev/tcp/time.windows.com/13`
`cat </dev/tcp/pool.ntp.org/13`
`cat </dev/tcp/time.google.com/13`
`cat </dev/tcp/time.apple.com/13`
`cat </dev/tcp/time.nrc.ca/13`
`cat </dev/tcp/time.windows.com/13`

Некоторые могут не работать.

Ну и как дополнительный вариант для проверки открытых портов, можно использовать __nc__.

`nc -zv bashdayz.ru 80`

Тут оно на экран тебе результат сразу вывалит без всяких костылей.

__nc или netcat__ - утилита, которая предоставляет возможность взаимодействия с сетью. Она может выполнять различные функции, такие как установка TCP или UDP соединений, передача данных между хостами, сканирование портов, создание простых серверов и т.п.

Ключ `-z` тестирует порт без передачи данных, а ключ `-v` логично что verbose (подробная инфа).

Да, ты скажешь можно же через nmap это все сделать, да, справедливо. Но я показываю как не пользоваться сторонними утилитами и получить желаемое с помощью bash. Пардон за nc, но не мог его не упомянуть.
